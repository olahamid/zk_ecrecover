{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":5671474703040319987,"abi":{"parameters":[{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"expected_address","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"boolean"},{"kind":"field"}]},"visibility":"public"},"error_types":{"4749531823446843009":{"error_kind":"string","string":"the signature is not safe: s> n"},"11314778477572923411":{"error_kind":"string","string":"resulting address is not the same as expecte address"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"/// @author - Ola Hamid\n/// @Title - zk_ecrecover\n/// @notice -  implemented an ECDSA signature verification system using Noir, with a specific focus on mitigating signature malleability and replay attacks.\n/// n: /*curved order*/ = 115792089237316195423570985008687907852837564279074904382605163141518161494337\n    /// e then we can check that s <= n/2\n    /// e SECp256k1 used as curve order in decimal(as it's mainly used in Cryptography elliptic curves)\nuse dep::ecrecover;\n// not needed again as i didn't change feild to array n the main branch\n//use nodash::pack_bytes;\n//----constant----//\n// SECP256K1 CURVE ORDER N\nfn _get_cover_order() -> ([u8; 32]) {\n    let CURVE_ODER: [u8; 32] = [ \n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n        0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,\n        0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41,\n    ];\n    (CURVE_ODER)\n}\nfn get_half_cover_order() -> ([u8; 32]) {\n    let HALF_CURVE_ORDER: [u8; 32] = [\n        0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,\n        0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0xA0\n    ];\n\n    HALF_CURVE_ORDER\n}\n\n//----data----//\nstruct EcrValue {\n    signature_r: [u8; 32],\n    signature_s: [u8; 32],\n    full_signature: [u8; 64],\n    half_n: [u8; 32],\n    full_n: [u8; 32],\n}\n\n//----Effect----//\ntrait compute_Ecrecover {\n    fn extract_signature_values(&mut self, sig: [u8; 64]);\n    fn is_signature_safe(&mut self) -> bool;\n}\n\nimpl compute_Ecrecover for EcrValue {\n    fn extract_signature_values(\n        &mut self, \n        sig: [u8; 64]) \n    {\n        \n        for i in 0..32 {\n            self.signature_r[i] = sig[i];\n            self.signature_s[i] = sig[i + 32];\n        }\n        // store the total sig in the struct \n        self.full_signature = sig;\n        // store the total to the half cover order\n        self.half_n = get_half_cover_order();\n\n        // store the total to the full coveer order\n        self.full_n = _get_cover_order();\n    }\n    \n    fn is_signature_safe(\n        &mut self\n    ) -> bool {\n\n        let s = self.signature_s;\n        let n_half = self.half_n;\n        let mut is_safe = false;\n        let mut is_break = false;\n        // compare s with n_half byte by byte \n        for i in 0..32 {\n            if (is_break == false) {\n                if (s[i] < n_half[i]) {\n                    is_safe =  true;\n                    is_break = true; \n                } else if(s[i] > n_half[i]) {\n                    is_safe = false;\n                    is_break = true;\n                }\n            // if the the both bytes are equal coninue to the next bytes\n            }\n        }\n        is_safe\n    }\n\n}   \n\nfn main (\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // r and s components concatenated\n    hashed_message: [u8; 32],\n    expected_address: Field, \n) -> pub ( bool, Field) {\n    \n    //get_cover_order();\n    let mut _ecr_values = EcrValue {\n        signature_r: [0; 32],\n        signature_s: [0; 32],\n        full_signature: [0; 64],\n        half_n: [0; 32],\n        full_n: [0; 32],\n    };\n    // setting data value.\n    _ecr_values.extract_signature_values(signature);\n\n    // making effect\n    let is_safe = _ecr_values.is_signature_safe();\n    \n    let address: Field = ecrecover::ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(is_safe, \"the signature is not safe: s> n\");\n    assert(address == expected_address, \"resulting address is not the same as expecte address\");\n\n    (is_safe, address)\n    \n}\n\n\n\n\n// use dep::ecrecover;\n// //use std::static_assert;\n// fn main(\n//     pub_key_x: [u8; 32],\n//     pub_key_y: [u8; 32],\n//     signature: [u8; 64], // r and s components concatenated\n//     hashed_message: [u8; 32],\n//     expected_address: Field // The Ethereum address derived from the public key\n// ) {\n//     // The ecrecover function attempts to recover an Ethereum address\n//     // from the public key, signature, and hashed message.\n//     // The 'false' argument indicates an Ethereum non-prefixed hash.\n//     let address: Field = ecrecover::ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    \n//     // Assert that the recovered address matches the expected address.\n//     // If they don't match, the proof will fail.\n//     assert(address == expected_address, \"Address does not match expected address\");\n// }\n","path":"/home/olahamid04/ZK/zk_ecrecover/src/main.nr"},"62":{"source":"mod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/olahamid04/nargo/github.com/colinnielsen/ecrecover-noir/v1.0.0/src/lib.nr"},"63":{"source":"use dep::keccak256;\nuse dep::array_helpers;\n\npub struct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    pub fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    pub fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64(self.pub_x, self.pub_y);\n        let hashed_pub_key = keccak256::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/olahamid04/nargo/github.com/colinnielsen/ecrecover-noir/v1.0.0/src/secp256k1.nr"},"66":{"source":"mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n","path":"/home/olahamid04/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert","directive_to_radix"]}